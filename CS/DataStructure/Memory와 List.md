## 메모리 저장

**메모리 저장 단위**

```markdown
💡
기본 1바이트.
0x00000000 ~ 0xFFFFFFFF에서 (32비트 운영체제 기준)
0x는 16진수라는 의미이고
하나의 숫자는 16까지 표현할 수 있다.(4비트란 소리)
4비트 * 8자리 이므로 = 32비트
32비트로 나타낼 수 있는 숫자는 
2^2 * (2^30) =(비슷함) 4 * (1000)^3 = 4GB까지 주소를 관리할 수 있다.
✅ 1000 = 1KB , 1000^2 = 1MB, 1000^3 = 1GB
32비트 운영체제를 이용하면서 8GB 램을 이용한다면 4GB는 사용하지 않는 셈,,!

64비트로 나타낼 수 있는 숫자는 ? 

지역 변수는 메모리의 stack에 할당된다.(주소도 거꾸로 할당 될 것.)
c++에서 배열의 포인터는 배열의 요소의 자료형에 대한 포인터에 담는다.
```

**메모리 저장 구조**

```markdown
정적⎡ Code : 함수, 제어문, 상수 ... 기계어로 프로그램 실행과 관련된 명령어가 적재되는 영역
할당⎜ Data : 전역 변수, 정적 변수. 프로그램 종료 시까지 메모리에 있음.
   ⎣ BSS  : 초기화 되지 않은 데이터 영역
동적⎡ Heap : 동적으로 할당하는 메모리 공간. GC, ARC에 의해 소멸이 결정된다.
할당⎣ Stack: 지역 변수, 매개변수, 리턴값 등... 자동으로 사용하는 임시 영역.(함수 호출 시 생성, 종료시 반환.)
```

정적 할당 : compile 타임에 메모리가 할당된다.

동적 할당 : runtime에 메모리가 할당된다.



### Array 배열

내부 인덱스를 이용해서 자료의 검색을 한번에 수행한다. 

- 검색 속도가 빠르다. 

  (인덱스로 접근하기 때문에 O(1)의 시간 복잡도를 갖는다. 시작 주소값에서 찾고자 하는 위치까지 사칙연산을 이용하기 때문)

- **크기**는 한 번 정하면 변경할 수 없다.🙅🏻 (생성할 때 이 배열의 크기를 기준으로 한번에 메모리를 확보해서 연속된 메모리를 이용한다.)

- 초기화 시에 메모리에 할당되어 ArrayList보다 속도가 빠르다.

- 논리적 저장 순서와 물리적 저장 순서가 일치한다. int 타입의 배열이라면 4바이트씩 주소가 커지게 된다.

  [0] 1 | 0x00

  [1] 2 | 0x04 

  [2] 3 | 0x08

  [3] 4 | 0x0C

  [4] 5 | 0x10

- `원소 삽입` 할 때는 공간이 충분하다면 `O(1)`, 공간이 없다면 새로 원소를 추가하고 인덱스를 재지정해야 하므로 `O(n)`

- `원소 삭제` 할 때는 자신보다 큰 인덱스를 하나씩 당겨와서 인덱스를 변환해야 하므로 `O(n)`.

- 메모리의 **stack** 영역에 할당된다.



### LinkedList

[head, 0x00] -> 0x00 : [1, 0x14] -> 0x14: [127, 0x20] -> ... 이런 식

- 자료의 주소 값으로 노드를 이용해 서로 연결되어 있는 구조.
- 메모리를 연속적으로 이용하지 않는다. (데이터와 다음 주소 값을 가지고 있음)
- 따라서 원소를 탐색할 때는 순차적으로 앞에서부터 접근해야 한다.
- `원소 삽입` 할 때는 처음과 끝인 경우 또는 중간 노드와 다음 노드의 인덱스를 아는 경우는 `O(1)`, 
  모르는 경우는 탐색을 해야하므로 `O(n)`의 시간 복잡도를 가진다.
- `원소 삭제`도 삽입과 마찬가지의 시간복잡도를 갖는다.
- 원소를 검색할 때는 위치를 찾기 위해 모든 원소를 검색해야 하므로 `O(n)`의 시간 복잡도를 갖는다.
- 메모리의 **heap** 영역에 할당된다.

### ArrayList

- 크기가 가변적이다.

- **내부적으로 배열**을 사용하기 때문에(인덱스를 이용해서) 검색이 빠르다. `O(1)`

- add(), remove()를 통해 추가/ 삭제가 가능하다. 시간 복잡도 (기존 사이즈가 가득 찼다면 인덱스 찾기 O(1) + 복사해서 새로 만들기O(n) = `O(n)` )

  📌 arraylist는 시작과 끝에서 삽입/삭제를 진행하더라도 모두 `O(n)`의 시간 복잡도를 갖는다.

  

 `💡 시작과 끝에 원소를 추가/삭제(O(1))할 일이 많다면 LinkedList를 이용하는 것이, `
`수정할 일(O(1))이 많다면 arraylist를 사용하는 것이 좋다. 공간 복잡도를 고려한다면 차례대로 데이터가 들어있는 arraylist!`



### HashMap 해시맵

🤔 해시맵은 내부적으로 어떻게 구현되어있을까?

✅ 해시맵은 데이터의 고유 값을 해시 메소드를 이용해서 인덱스로 만들어 데이터를 저장하기 때문에 검색 속도가 빠른 자료구조이다. `O(1)` 

인덱스를 가지므로 내부적으로 배열을 사용해서 데이터를 저장한다.

### HashTable 해시테이블과의 차이점

✅ 해시 테이블은 `public synchronized V put(K key, V value) {}` 로 병렬처리를 하면서 자원의 동기화를 지원하고

해시 맵은 `public V put(K key, V value) {}`로 자원의 동기화를 지원하지 않는 상황에 사용한다.



### HashTable

해시 테이블의 고유 인덱스가 충돌하게 되면 chaining에 연결된 리스트를 확인해야 하므로 검색에 `O(N)`의 시간 복잡도를 갖는다. 

(그 외에는 평균 `O(1)`의 시간 복잡도)

⛔️해시값이 충돌하는 경우⛔️

1. 분리 연결법(Seperate Chaining)
2. 개방 주소법(Open )
